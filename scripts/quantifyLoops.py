#!/usr/bin/env python
#--coding:utf-8 --
"""
"""
__date__ = "2020-01-19"
__modified__ = ""
__email__ = "caoyaqiang@picb.ac.cn"

#general library
import os,argparse
import logging

#3rd library
import numpy as np
import pandas as pd
from scipy.stats import poisson
from joblib import Parallel, delayed

#cLoops
from cLoops.utils import getLogger, cFlush, deloopHelp
from cLoops.io import parseIv
from cLoops.cModel import getGenomeCoverage, getCounts, getNearbyPairRegions, getPETsforRegions, getBonPvalues

#global settings
global logger


def help():
    """
    Create the command line interface for the script of deLoops 
    """
    description = """
        Quantify loops from cLoops called. 
        For example:
        quantifyLoops.py -f a.loop -d A -o fout -p 10 
        """
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument(
        "-f",
        dest="f",
        required=True,
        type=str,
        help=
        "Loops file called by cLoops. Only using significant loops as mark 1, you can change this in the .loop file."
    )
    parser.add_argument(
        "-d",
        dest="d",
        required=True,
        type=str,
        help=
        "Directory for .jd files of loop file a, generated by cLoops with option -s 1."
    )
    parser.add_argument(
        "-o",
        dest="output",
        required=True,
        type=str,
        help=
        "Output file name prefix. "
    )
    parser.add_argument(
        "-p",
        dest="cpu",
        required=False,
        default=1,
        type=int,
        help=
        "CPU number used to run the job, default is 1,set -1 to use all cpus available. Too many CPU could cause memory error."
    )
    parser.add_argument(
        "-c",
        dest="chroms",
        required=False,
        default="",
        type=str,
        help=
        "Whether to process limited chroms, specify it as chr1,chr2,chr3, default is not. Set it to the same one for cLoops."
    )
    parser.add_argument(
        "-dis",
        dest="dis",
        required=False,
        default=0,
        type=int,
        help=
        "Set a distance cutoff to filter PETs, could be the inter-ligation and self-ligation cutoff, default is 0."
    )

    op = parser.parse_args()
    return op


def preDs(f, d, chroms=[], ivac=6, ivbc=7):
    """
    Prepare input datasets, f is the .loop file and d is the directory contains parsed cis-PETs.
    """
    records = {}  #organized by chromosomes.
    if len(chroms) > 0:
        for c in chroms:
            records[c] = {"rs": {}, "f": ""}
    for i, line in enumerate(open(f)):
        if i == 0:
            continue
        line = line.split("\n")[0].split("\t")
        #only using significant loops
        if float(line[-1]) < 1:
            continue
        iva = parseIv(line[ivac])
        ivb = parseIv(line[ivbc])
        if len(chroms) > 0 and iva[0] not in chroms:
            continue
        if iva[0] not in records:
            records[iva[0]] = {"rs": {}, "f": ""}
        records[iva[0]]["rs"][line[0]] = iva + ivb
    for chrom in records.keys():
        if len(records[chrom]["rs"]) == 0:
            del records[chrom]
            continue
        f = os.path.join(d, "%s-%s.jd" % (chrom, chrom))
        if os.path.isfile(f):
            records[chrom]["f"] = f
        else:
            logger.warning(
                "%s not found, however there are loops in that chromosome." %
                f)
            del records[chrom]
    return records


def getPermutatedBg(ivas, ivbs, model):
    rabs = []
    for na in ivas:
        for nb in ivbs:
            ra, rb, rab = getPETsforRegions(na, nb, model)
            rabs.append( rab )
    #to escape warning RuntimeWarning: Mean of empty slice, this will leads to nan
    if len(rabs) == 0:
        mrabs = 0.0
    else:
        mrabs = float(np.mean(rabs))
    return mrabs


def estSigOneChr(rs, jdf,  pre, dis=0,win=5):
    """
    Estimating the significances for the loops in one chromosome.
    """
    #all variables with suffix t is treatment, with suffix c in control
    logger.info("Building genomic coverage model for %s" % jdf)
    model, N = getGenomeCoverage(jdf, dis)
    ds = {}
    i = 0
    for key, r in rs.items():
        i += 1
        if i % 100 == 0:
            report = "Estimating %s loops for %s" % (i, pre)
            cFlush(report)
        chrom = r[0]
        iva = [r[1], r[2]]
        ivb = [r[4], r[5]]
        ra, rb, rab = getPETsforRegions(iva, ivb, model)
        ivas, ivbs = getNearbyPairRegions(iva, ivb, win=win)
        mrab = getPermutatedBg(ivas, ivbs, model)
        if mrab > 0:
            es = rab / mrab
        else:
            es = 100
        pop = max([1e-300, poisson.sf(rab - 1.0, mrab)])
        niva = "%s:%s-%s" % (chrom, iva[0], iva[1])
        nivb = "%s:%s-%s" % (chrom, ivb[0], ivb[1])
        ds[key] = {
            "iva": niva,
            "ivb": nivb,
            "ra":ra,
            "rb":rb,
            "rab":rab,
            "ES": es,
            "poisson_p-value": pop,
        }
    if len(ds) == 0:
        return None
    ds = pd.DataFrame(ds).T
    return ds


def quantifyLoops(ra, prea, dis=0, cpu=1):
    ds = Parallel(n_jobs=cpu)(delayed(estSigOneChr)( ra[key]["rs"], ra[key]["f"], key, dis) for key in ra.keys())
    ds = [d for d in ds if d is not None]
    ds = pd.concat(ds)
    ds.to_csv(prea + "_quantLoops.txt", sep="\t", index_label="loopId")


def main():
    global logger
    fn = os.path.join(os.getcwd(), "quantifyLoops.log")
    logger = getLogger(fn)
    op = help()
    if op.chroms == "":
        chroms = []
    else:
        chroms = set(op.chroms.split(","))
    cfa, dfa = op.f, op.d
    ra = preDs(cfa, dfa, chroms)
    keys = ra.keys()
    for key in ra.keys():
        if key not in keys:
            del ra[key]
            logger.info("No match of %s in %s or %s" % (key, cfa, dfa))
    quantifyLoops(ra,op.output, op.dis, op.cpu)


main()
